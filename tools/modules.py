#!/usr/bin/env python

# Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
# Improved by Majid Moghadam - UCSC - ASL
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

# Allows visualising a 2D map generated by vehicles.

# ==============================================================================
# -- imports -------------------------------------------------------------------
# ==============================================================================

"""
my name is bao wenhua
Example of automatic vehicle control from client side.
"""

import glob
import os
import sys

import carla
from carla import TrafficLightState as tls

import logging
import datetime
import weakref
import math
import random
import re
import sys
import weakref

from carla import ColorConverter as cc
import argparse
import collections
import datetime
import logging
import math
import random
import re
import weakref
import threading
import datetime

from typing import Tuple, Union, List
from carla_gym.envs.wrapper import *
from  plan_control.controller import VehiclePIDController
from plan_control.controller import IntelligentDriverModel
from plan_control.frenet_optimal_trajectory import frenet_to_inertial
from tools.misc import get_speed
from config import cfg
import pygame
import numpy as np
from collections import deque



# Module Defines
MODULE_WORLD = 'WORLD'
MODULE_HUD = 'HUD'
MODULE_CONTROL = 'CONTROL'
MODULE_INPUT = 'INPUT'
MODULE_TRAFFIC = 'TRAFFIC'

PIXELS_PER_METER = 12

MAP_DEFAULT_SCALE = 0.1
HERO_DEFAULT_SCALE = 1.0

PIXELS_AHEAD_VEHICLE = 150

# ==============================================================================
# -- Util -----------------------------------------------------------
# ==============================================================================

def euclidean_distance(v1, v2):
    return math.sqrt(sum([(a - b) ** 2 for a, b in zip(v1, v2)]))


def get_actor_display_name(actor, truncate=250):
    name = ' '.join(actor.type_id.replace('_', '.').title().split('.')[1:])
    return (name[:truncate - 1] + u'\u2026') if len(name) > truncate else name


class Util:

    @staticmethod
    def blits(destination_surface, source_surfaces, rect=None, blend_mode=0):
        for surface in source_surfaces:
            destination_surface.blit(surface[0], surface[1], rect, blend_mode)

    @staticmethod
    def length(v):
        return math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2)

    @staticmethod
    def get_bounding_box(actor):
        bb = actor.trigger_volume.extent
        corners = [carla.Location(x=-bb.x, y=-bb.y),
                   carla.Location(x=bb.x, y=-bb.y),
                   carla.Location(x=bb.x, y=bb.y),
                   carla.Location(x=-bb.x, y=bb.y),
                   carla.Location(x=-bb.x, y=-bb.y)]
        corners = [x + actor.trigger_volume.location for x in corners]
        t = actor.get_transform()
        t.transform(corners)
        return corners

class ModuleWorld(CarlaActorBase):
    def __init__(self, args, client, world):
        self.args = args
        self.actor_role_name = args.rolename
        self.server_fps = 0.0
        self.simulation_time = 0
        self.dt = float(cfg.CARLA.DT)
        self.clock = pygame.time.Clock()
        #world data
        self.client = client
        self.world = world.get_carla_world()
        self._map = world.get_carla_map()
        self.tm_port = self.client.get_trafficmanager(self.args.tm_port).get_port()
        self.actors_with_transforms = []

        # Hero actor
        self.hero_actor = None
        self.hero_transform = None
        self.start()
        #motion planner
        self.global_csp = None
        self.points_to_draw = {}
        self.LANE_WIDTH = float(cfg.CARLA.LANE_WIDTH)
        self.init_s = 50  # ego initial s location
        self.init_d = 0 * self.LANE_WIDTH  # ego initial lane number - int range: [-1, 2]  => change in reset function
        self._gamma = args.gamma
        self.max_s = int(cfg.CARLA.MAX_S)
        self.track_length = int(cfg.GYM_ENV.TRACK_LENGTH)
        super().__init__(world, self.hero_actor)

    def update_global_route_csp(self, global_route_csp):
        self.global_csp = global_route_csp

    def get_collision_history(self):
        return self.collision_hist

    def inertial_to_body_frame(self, xi, yi, psi):
        Xi = np.array([xi, yi])  # inertial frame
        R_psi_T = np.array([[np.cos(psi), np.sin(psi)],  # Rotation matrix transpose
                            [-np.sin(psi), np.cos(psi)]])
        Xt = np.array([self.hero_actor.get_transform().location.x,  # Translation from inertial to body frame
                       self.hero_actor.get_transform().location.y])
        Xb = np.matmul(R_psi_T, Xi - Xt)
        return Xb

    def body_to_inertial_frame(self, xb, yb, psi):
        Xb = np.array([xb, yb])  # inertial frame
        R_psi = np.array([[np.cos(psi), -np.sin(psi)],  # Rotation matrix
                          [np.sin(psi), np.cos(psi)]])
        Xt = np.array([self.hero_actor.get_transform().location.x,  # Translation from inertial to body frame
                       self.hero_actor.get_transform().location.y])
        Xi = np.matmul(R_psi, Xb) + Xt
        return Xi

    def start(self):

        blueprint = self.world.get_blueprint_library().filter('vehicle.tesla.model3')[0]
        blueprint.set_attribute('role_name', 'hero')
        if blueprint.has_attribute('color'):
            color = '10,0,0'  # Red
            blueprint.set_attribute('color', color)

        x, y, z, yaw = frenet_to_inertial(self.init_s, self.init_d, self.global_csp)
        z += 0.1

        spawn_point = carla.Transform(location=carla.Location(x=x, y=y, z=z),
                                      rotation=carla.Rotation(pitch=0.0, yaw=math.degrees(yaw), roll=0.0))
        self.init_spawn_point = spawn_point
        self.hero_actor = self.world.spawn_actor(blueprint, spawn_point)
        self.hero_actor.set_autopilot(False, self.tm_port)
        print('Spawned ego in: ', spawn_point)
        self.hero_actor.set_autopilot(False, self.tm_port)
        self.hero_transform = self.hero_actor.get_transform()

    def _split_actors(self):
        vehicles = []
        traffic_lights = []
        speed_limits = []
        walkers = []

        for actor_with_transform in self.actors_with_transforms:
            actor = actor_with_transform[0]
            if 'vehicle' in actor.type_id:
                vehicles.append(actor_with_transform)
            elif 'traffic_light' in actor.type_id:
                traffic_lights.append(actor_with_transform)
            elif 'speed_limit' in actor.type_id:
                speed_limits.append(actor_with_transform)
            elif 'walker' in actor.type_id:
                walkers.append(actor_with_transform)

        return (vehicles, traffic_lights, speed_limits, walkers)


# ==============================================================================
# -- Vehicle Cruise Control ----------------------------------------------------
# ==============================================================================


class CruiseControl:
    def __init__(self, vehicle, los_sensor, s, d, lane, module_manager, targetSpeed=50 / 3.6):
        self.vehicle = vehicle  # Carla instance for the vehicle
        self.id = self.vehicle.id
        self.s = s
        self.d = d  # actor won't change lane so d is constant
        self.lane = lane
        self.module_manager = module_manager
        self.targetSpeed = targetSpeed
        self.world = self.module_manager.get_module(MODULE_WORLD)
        self.steps = 0
        if float(cfg.CARLA.DT) > 0:
            self.dt = float(cfg.CARLA.DT)
        else:
            self.dt = 0.05
        self.vehicleController = VehiclePIDController(self.vehicle)
        self.IDM = IntelligentDriverModel(self.vehicle)

        self.los_sensor = los_sensor

        self.location = self.vehicle.get_location()
        self.speed = get_speed(self.vehicle)
        self.acceleration = 0
        self.yaw = math.radians(self.vehicle.get_transform().rotation.yaw)
        self.LANE_WIDTH = float(cfg.CARLA.LANE_WIDTH)

    def update_s(self, s):
        self.s = s

    def inertial_to_body_frame(self, xi, yi):
        Xi = np.array([xi, yi])  # inertial frame
        R_psi_T = np.array([[np.cos(self.yaw), np.sin(self.yaw)],  # Rotation matrix transpose
                            [-np.sin(self.yaw), np.cos(self.yaw)]])
        Xt = np.array([self.location.x,  # Translation from inertial to body frame
                       self.location.y])
        Xb = np.matmul(R_psi_T, Xi - Xt)
        return Xb

    def body_to_inertial_frame(self, xb, yb):
        Xb = np.array([xb, yb])  # inertial frame
        R_psi = np.array([[np.cos(self.yaw), -np.sin(self.yaw)],  # Rotation matrix
                          [np.sin(self.yaw), np.cos(self.yaw)]])
        Xt = np.array([self.location.x,  # Translation from inertial to body frame
                       self.location.y])
        Xi = np.matmul(R_psi, Xb) + Xt
        return Xi

    def tick(self):
        self.steps += 1
        self.location = self.vehicle.get_location()
        speed_ = self.speed # speed in previous tick
        self.speed = get_speed(self.vehicle)
        self.acceleration = (self.speed - speed_) / self.dt
        self.yaw = math.radians(self.vehicle.get_transform().rotation.yaw)

        nextWP = self.world.town_map.get_waypoint(self.location, project_to_road=True).next(distance=5)[0]
        targetWP = [nextWP.transform.location.x, nextWP.transform.location.y]

        if self.lane == 2 and nextWP.is_junction:  # only if in right most lane
            temploc = self.body_to_inertial_frame(xb=0, yb=-self.LANE_WIDTH)
            tempWP = self.world.town_map.get_waypoint(carla.Location(x=temploc[0], y=temploc[1]), project_to_road=True).next(distance=10)[0]
            tempWPb = self.inertial_to_body_frame(xi=tempWP.transform.location.x, yi=tempWP.transform.location.y)
            targetWP = self.body_to_inertial_frame(xb=tempWPb[0], yb=tempWPb[1] + self.LANE_WIDTH)

        vehicle_ahead = self.los_sensor.get_vehicle_ahead()
        cmdSpeed = self.IDM.run_step(vd=self.targetSpeed, vehicle_ahead=vehicle_ahead)

        control = self.vehicleController.run_step(cmdSpeed, targetWP)
        self.vehicle.apply_control(control)

        return [self.location.x, self.location.y, self.location.z, self.speed, self.acceleration, self.yaw]


