#!/usr/bin/env python

# Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
# Improved by Majid Moghadam - UCSC - ASL
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

# Allows visualising a 2D map generated by vehicles.

"""
Welcome to CARLA No-Rendering Mode Visualizer

    TAB          : toggle hero mode
    Mouse Wheel  : zoom in / zoom out
    Mouse Drag   : move map (map mode only)

    W            : throttle
    S            : brake
    AD           : steer
    Q            : toggle reverse
    Space        : hand-brake
    P            : toggle autopilot
    M            : toggle manual transmission
    ,/.          : gear up/down

    F1           : toggle HUD
    I            : toggle actor ids
    H/?          : toggle help
    ESC          : quit
"""

# ==============================================================================
# -- imports -------------------------------------------------------------------
# ==============================================================================

import glob
import os
import sys

try:
    sys.path.append(glob.glob('../carla/dist/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])
except IndexError:
    pass

import carla
from carla import TrafficLightState as tls

import logging
import datetime
import weakref
import math
import random

from carla import ColorConverter as cc

# from operator import itemgetter
from plan_control.controller import VehiclePIDController
from plan_control.controller import IntelligentDriverModel
from plan_control.frenet_optimal_trajectory import frenet_to_inertial
from tools.misc import get_speed
from config import cfg

import numpy as np
from collections import deque

# ==============================================================================
# -- Constants -----------------------------------------------------------------
# ==============================================================================

# Colors

# We will use the color palette used in Tango Desktop Project (Each color is indexed depending on brightness level)
# See: https://en.wikipedia.org/wiki/Tango_Desktop_Project

# Module Defines
MODULE_WORLD = 'WORLD'
MODULE_CONTROL = 'CONTROL'
MODULE_INPUT = 'INPUT'
MODULE_TRAFFIC = 'TRAFFIC'

PIXELS_PER_METER = 12

MAP_DEFAULT_SCALE = 0.1
HERO_DEFAULT_SCALE = 1.0

PIXELS_AHEAD_VEHICLE = 150


# ==============================================================================
# -- Util -----------------------------------------------------------
# ==============================================================================

def euclidean_distance(v1, v2):
    return math.sqrt(sum([(a - b) ** 2 for a, b in zip(v1, v2)]))


def get_actor_display_name(actor, truncate=250):
    name = ' '.join(actor.type_id.replace('_', '.').title().split('.')[1:])
    return (name[:truncate - 1] + u'\u2026') if len(name) > truncate else name


class Util:

    @staticmethod
    def blits(destination_surface, source_surfaces, rect=None, blend_mode=0):
        for surface in source_surfaces:
            destination_surface.blit(surface[0], surface[1], rect, blend_mode)

    @staticmethod
    def length(v):
        return math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2)

    @staticmethod
    def get_bounding_box(actor):
        bb = actor.trigger_volume.extent
        corners = [carla.Location(x=-bb.x, y=-bb.y),
                   carla.Location(x=bb.x, y=-bb.y),
                   carla.Location(x=bb.x, y=bb.y),
                   carla.Location(x=-bb.x, y=bb.y),
                   carla.Location(x=-bb.x, y=-bb.y)]
        corners = [x + actor.trigger_volume.location for x in corners]
        t = actor.get_transform()
        t.transform(corners)
        return corners


# ==============================================================================
# -- ModuleManager -------------------------------------------------------------
# ==============================================================================


class ModuleManager:
    def __init__(self):
        self.modules = []

    def register_module(self, module):
        self.modules.append(module)

    def clear_modules(self):
        del self.modules[:]

    def tick(self):
        # Update all the modules
        for module in self.modules:
            module.tick()

    def get_module(self, name):
        for module in self.modules:
            if module.name == name:
                return module

    def start_modules(self):
        for module in self.modules:
            module.start()

    def exit_game(self):
        self.clear_modules()
        sys.exit()

import time
class ModuleWorld:
    def __init__(self, name, args, timeout, module_manager):
        self.module_manager = module_manager
        #self.width = width
        #self.height = height
        # if args.play_mode:
        #     # Init Pygame
        #     pygame.init()
        #     self.display = pygame.display.set_mode((1280, 720), pygame.HWSURFACE | pygame.DOUBLEBUF)
        #     pygame.display.set_caption('CARLA No Rendering Mode Visualizer')
        #
        #     font = pygame.font.Font(pygame.font.get_default_font(), 20)
        #     text_surface = font.render('Rendering map...', True, COLOR_WHITE)
        #     self.display.blit(text_surface, text_surface.get_rect(center=(1280 / 2, 720 / 2)))
        #     pygame.display.flip()
        #     self.traffic_light_surfaces = TrafficLightSurfaces() if args.play_mode == 1 else None
        #     self.clock = pygame.time.Clock()
        #     self.server_clock = pygame.time.Clock()
        self.name = name
        self.args = args
        self.timeout = 20.0
        self.server_fps = 0.0
        self.simulation_time = 0

        if float(cfg.CARLA.DT) > 0:
            self.dt = float(cfg.CARLA.DT)
        else:
            self.dt = None

        # World data
        self.world = None
        self.town_map = None
        self.world, self.town_map = self._get_data_from_carla()
        self.actors_with_transforms = []

        # Store necessary modules
        self.surface_size = [0, 0]
        self.prev_scaled_size = 0
        self.scaled_size = 0

        # Hero actor
        self.hero_actor = None
        self.hero_transform = None

        # sensors
        self.collision_sensor = None
        self.collision_hist = None

        self.scale_offset = [0, 0]


        self.affected_traffic_light = None

        self.points_to_draw = {}  # add waypoints to this dictionary to visualize them in Pygame
        self.global_csp = None
        self.LANE_WIDTH = float(cfg.CARLA.LANE_WIDTH)
        self.init_s = 50  # ego initial s location
        self.init_d = 0 * self.LANE_WIDTH  # ego initial lane number - int range: [-1, 2]  => change in reset function
        self.max_s = int(cfg.CARLA.MAX_S)
        self.track_length = int(cfg.GYM_ENV.TRACK_LENGTH)

    def update_global_route_csp(self, global_route_csp):
        self.global_csp = global_route_csp

    def get_collision_history(self):
        return self.collision_hist

    def inertial_to_body_frame(self, xi, yi, psi):
        Xi = np.array([xi, yi])  # inertial frame
        R_psi_T = np.array([[np.cos(psi), np.sin(psi)],  # Rotation matrix transpose
                            [-np.sin(psi), np.cos(psi)]])
        Xt = np.array([self.hero_actor.get_transform().location.x,  # Translation from inertial to body frame
                       self.hero_actor.get_transform().location.y])
        Xb = np.matmul(R_psi_T, Xi - Xt)
        return Xb

    def body_to_inertial_frame(self, xb, yb, psi):
        Xb = np.array([xb, yb])  # inertial frame
        R_psi = np.array([[np.cos(psi), -np.sin(psi)],  # Rotation matrix
                          [np.sin(psi), np.cos(psi)]])
        Xt = np.array([self.hero_actor.get_transform().location.x,  # Translation from inertial to body frame
                       self.hero_actor.get_transform().location.y])
        Xi = np.matmul(R_psi, Xb) + Xt
        return Xi

    def config(self, synchronous=True, no_rendering=True, time_step=None):
        self.world.tick()
        self.initSettings = self.world.get_settings()  # backup the initial setting
        print('initial settings: ', self.initSettings)
        settings = self.world.get_settings()
        settings.synchronous_mode = synchronous
        settings.no_rendering_mode = no_rendering
        settings.fixed_delta_seconds = time_step  # None: default; variable time-step
        self.world.apply_settings(settings)

    def recoverConfig(self):
        self.world.apply_settings(self.initSettings)  # recover initial setting

    def _get_data_from_carla(self):
        try:
            self.client = carla.Client(self.args.carla_host, self.args.carla_port)
            self.client.set_timeout(self.timeout)
            self.tm_port = self.client.get_trafficmanager(self.args.tm_port).get_port()
            # world = self.client.get_world()
            world = self.client.load_world('Town04')
            world.set_weather(getattr(carla.WeatherParameters, 'ClearNoon'))
            print('Map: Town04 --- Weather: ClearNoon')
            town_map = world.get_map()
            return world, town_map

        except RuntimeError as ex:
            logging.error(ex)
            self.module_manager.exit_game()

    def start(self):
        self.config(synchronous=True, no_rendering=False, time_step=self.dt)
        settings = self.world.get_settings()
        print('fixed_delta_seconds= ', settings.fixed_delta_seconds)
        print('changed settings to: ', settings)

        # Start hero mode by default
        # self.select_hero_actor()
        self._spawn_hero()
        self.hero_actor.set_autopilot(False, self.tm_port)


    def _spawn_hero(self):

        blueprint = self.world.get_blueprint_library().filter('vehicle.tesla.model3')[0]
        blueprint.set_attribute('role_name', 'hero')
        if blueprint.has_attribute('color'):
            color = '10,0,0'  # Red
            blueprint.set_attribute('color', color)

        x, y, z, yaw = frenet_to_inertial(self.init_s, self.init_d, self.global_csp)
        z += 0.1

        spawn_point = carla.Transform(location=carla.Location(x=x, y=y, z=z), rotation=carla.Rotation(pitch=0.0, yaw=math.degrees(yaw), roll=0.0))
        self.hero_actor = self.world.spawn_actor(blueprint, spawn_point)
        self.hero_actor.set_autopilot(False, self.tm_port)
        print('Spawned ego in: ', spawn_point)

        self.hero_transform = self.hero_actor.get_transform()

        # collision sensor
        self.collision_sensor = CollisionSensor(self.hero_actor)
        self.los_sensor = LineOfSightSensor(self.hero_actor)


    def reset(self):
        # remove collision history
        self.collision_sensor.reset()
        self.los_sensor.reset()

        # Set ego transform

        self.init_s = np.random.uniform(50, self.max_s - self.track_length - 50)  # ego initial s location
        #  should be larger than 50. bc other actors will be spawned in range: s = [init_s-50, init_s+150]
        #  should be smaller than max_s - track_length to have all tracks with the same length

        self.init_d = np.random.randint(-1, 3) * self.LANE_WIDTH  # -1 and 3 because global route is defined on the second lane from left

        x, y, z, yaw = frenet_to_inertial(self.init_s, self.init_d, self.global_csp)
        z += 0.1

        self.hero_actor.set_velocity(carla.Vector3D(x=0, y=0, z=0))
        self.hero_actor.set_angular_velocity(carla.Vector3D(x=0, y=0, z=0))
        transform = carla.Transform(location=carla.Location(x=x, y=y, z=z), rotation=carla.Rotation(pitch=0.0, yaw=math.degrees(yaw), roll=0.0))
        self.hero_actor.set_transform(transform)
        self.spectator = self.world.get_spectator()
        transform = self.hero_actor.get_transform()
        self.spectator.set_transform(carla.Transform(transform.location + carla.Location(z=50),
                                                carla.Rotation(pitch=-90)))
        time.sleep(5)

    def tick(self):
        actors = self.world.get_actors()
        self.actors_with_transforms = [(actor, actor.get_transform()) for actor in actors]
        if self.hero_actor is not None:
            self.hero_transform = self.hero_actor.get_transform()
        self.world.tick()
        self.collision_hist = self.collision_sensor.get_collision_history()


    @staticmethod
    def on_world_tick(weak_self, timestamp):
        self = weak_self()
        if not self:
            return

        self.server_clock.tick()
        self.server_fps = self.server_clock.get_fps()
        self.simulation_time = timestamp.elapsed_seconds

    def _split_actors(self):
        vehicles = []
        traffic_lights = []
        speed_limits = []
        walkers = []

        for actor_with_transform in self.actors_with_transforms:
            actor = actor_with_transform[0]
            if 'vehicle' in actor.type_id:
                vehicles.append(actor_with_transform)
            elif 'traffic_light' in actor.type_id:
                traffic_lights.append(actor_with_transform)
            elif 'speed_limit' in actor.type_id:
                speed_limits.append(actor_with_transform)
            elif 'walker' in actor.type_id:
                walkers.append(actor_with_transform)

        info_text = []
        if self.hero_actor is not None and len(vehicles) > 1:
            location = self.hero_transform.location
            vehicle_list = [x[0] for x in vehicles if x[0].id != self.hero_actor.id]

            def distance(v):
                return location.distance(v.get_location())

            for n, vehicle in enumerate(sorted(vehicle_list, key=distance)):
                if n > 15:
                    break
                vehicle_type = get_actor_display_name(vehicle, truncate=22)
                info_text.append('% 5d %s' % (vehicle.id, vehicle_type))
        return (vehicles, traffic_lights, speed_limits, walkers)

    def destroy(self):
        print('destroying vehicle actors ...')
        for actor in self.world.get_actors():
            if 'vehicle' in actor.type_id or 'sensor' in actor.type_id:
                actor.destroy()
        if self.world is not None:
            print('recovering world initial configuration ...')
            self.recoverConfig()

# ==============================================================================
# -- Collision Sensor ----------------------------------------------------------
# ==============================================================================

class CollisionSensor(object):
    def __init__(self, parent_actor):
        self.sensor = None
        self.history = []
        self._parent = parent_actor
        world = self._parent.get_world()
        bp = world.get_blueprint_library().find('sensor.other.collision')
        self.sensor = world.spawn_actor(bp, carla.Transform(), attach_to=self._parent)
        # We need to pass the lambda a weak reference to self to avoid circular
        # reference.
        weak_self = weakref.ref(self)
        self.sensor.listen(lambda event: CollisionSensor._on_collision(weak_self, event))

    def reset(self):
        self.history = []

    def get_collision_history(self):
        return self.history

    @staticmethod
    def _on_collision(weak_self, event):
        self = weak_self()
        if not self:
            return
        self.history.append(True)


# ==============================================================================
# -- Traffic manager ----------------------------------------------------------------
# ==============================================================================

class TrafficManager:
    def __init__(self, name, module_manager):
        self.name = name
        self.module_manager = module_manager
        self.world_module = None
        self.world = None
        self.blueprints = None
        self.global_csp = None  # Global cubic spline used for spawning actors on the main road
        self.tm_port = None
        # a list of dictionaries, each for an actor.
        # Dictionary keys:
        # actor: carla actor instance | sensor: range sensor | control: CruiseControl instance | Frenet State: [s, d]
        self.actors_batch = []

        self.N_SPAWN_CARS = int(cfg.TRAFFIC_MANAGER.N_SPAWN_CARS)
        self.min_speed = float(cfg.TRAFFIC_MANAGER.MIN_SPEED)
        self.max_speed = float(cfg.TRAFFIC_MANAGER.MAX_SPEED)
        self.LANE_WIDTH = float(cfg.CARLA.LANE_WIDTH)
        self.max_s = int(cfg.CARLA.MAX_S)
        self.track_length = int(cfg.GYM_ENV.TRACK_LENGTH)

    def update_global_route_csp(self, global_route_csp):
        self.global_csp = global_route_csp

    def estimate_s(self, s, x, y, yaw):
        """
        receive last s value and current state then estimate current s value
        """

        def normalize(vector):
            if sum(vector) == 0:
                return [0 for _ in range(len(vector))]
            return vector / np.sqrt(sum([n ** 2 for n in vector]))

        def magnitude(vector):
            return np.sqrt(sum([n ** 2 for n in vector]))

        # ------------------------ UPDATE S VALUE ------------------------------------ #
        # We calculate normal vector of s line and find error_s based on ego location. Note: This assumes error is small angle
        def update_s(current_s):
            s_yaw = self.global_csp.calc_yaw(current_s)
            s_x, s_y, s_z = self.global_csp.calc_position(current_s)
            ego_yaw = yaw
            s_norm = normalize([-np.sin(s_yaw), np.cos(s_yaw)])
            v1 = [x - s_x, y - s_y]
            v1_norm = normalize(v1)
            angle = np.arccos(np.clip(np.dot(s_norm, v1_norm), -1.0, 1.0))
            delta_s = np.sin(angle) * magnitude(
                v1)  # Since we use last coordinate of trajectory as possible ego location we know actual location is behind most of the time
            # print("delta_s:{}".format(delta_s))
            return delta_s

        estimated_s = s % self.max_s
        estimated_s -= update_s(estimated_s)
        estimated_s = estimated_s % self.max_s
        estimated_s += update_s(estimated_s)
        estimated_s = estimated_s % self.max_s

        return estimated_s

    def spawn_one_actor(self, s, lane, targetSpeed):
        """
        Spawn an actor on the main road based on the frenet s and d values
        """
        if self.global_csp is None:
            return

        d = lane * self.LANE_WIDTH
        x, y, z, yaw = frenet_to_inertial(s, d, self.global_csp)

        blueprint = random.choice(self.blueprints)
        if blueprint.has_attribute('color'):
            color = random.choice(blueprint.get_attribute('color').recommended_values)
            blueprint.set_attribute('color', color)

        transform = carla.Transform(location=carla.Location(x=x, y=y, z=z + 0.3), rotation=carla.Rotation(pitch=0.0, yaw=math.degrees(yaw), roll=0.0))

        otherActor = self.world.try_spawn_actor(blueprint, transform)

        # otherActor.set_transform(transform)
        if otherActor is not None:
            # create a line of sight sensor attached to the vehicle
            los_sensor = LineOfSightSensor(otherActor)
            otherActor.set_autopilot(False, self.tm_port)
            otherActor.set_velocity(carla.Vector3D(x=0, y=0, z=0))
            otherActor.set_angular_velocity(carla.Vector3D(x=0, y=0, z=0))
            # keep actors and sensors to destroy them when an episode is finished
            cruiseControl = CruiseControl(otherActor, los_sensor, s, d, lane, self.module_manager, targetSpeed=targetSpeed)
            deq_s = deque([s], maxlen=50)
            self.actors_batch.append({'Actor': otherActor, 'Sensor': los_sensor, 'Cruise Control': cruiseControl, 'Frenet State': [deq_s, d]})
        return otherActor

    def start(self):
        self.world_module = self.module_manager.get_module(MODULE_WORLD)
        self.world = self.world_module.world
        self.tm_port = self.world_module.tm_port
        blueprints = self.world.get_blueprint_library().filter('vehicle.mercedes-benz.coupe')
        self.blueprints = [bp for bp in blueprints if int(bp.get_attribute('number_of_wheels')) == 4]

    def reset(self, ego_s, ego_d):
        """
        Spawn random N_INIT_CARS in random blocks of a grid world
        Grid locations: from s = egos_s - 20 to s = egos_s + 170 in frenet frame
        Grid numbers are in range [0, 79]. Each actor will be spawned in a random grid
        It's possible for an actor to be be spawned at the ego location, so we remove the ego grid number from the grid choices.
        Grid world indices:
        row   0   1  2  ... 19      <== column
              ----------------
        -1 |  0   4  8  ... 76
         0 |  1   5  9  ... 77
         1 |  2   6  10 ... 78
         2 |  3   7  11 ... 79
         grid width = Lane width = 3.5 (m)
         grid length = 10 (m)
         ego col = 2
         ego row/lane = randomly initialized
        """
        # remove actors and sensors
        for actor_dic in self.actors_batch:
            actor_dic['Actor'].destroy()
            actor_dic['Sensor'].destroy()

        # delete class instances and re-initialize lists
        del self.actors_batch[:]

        # re-spawn N_INIT_CARS of actors
        ego_lane = int(ego_d / self.LANE_WIDTH)
        ego_grid_n = ego_lane + 9  # in Grid world (see notes above), ego is in column 2 so its grid number will be based on its lane number
        grid_choices = np.arange(16, 60)

        rnd_indices = np.random.choice(grid_choices, self.N_SPAWN_CARS, replace=False)
        for idx in rnd_indices:
            col = idx // 4  # col number [0, 19]
            lane = idx - col * 4 - 1  # lane number [-1, 2]
            s = ego_s + col * 10 - 20  # -20 bc ego is on second column
            targetSpeed = random.uniform(self.min_speed, self.max_speed)  # m/s
            self.spawn_one_actor(s, lane, targetSpeed)

    def destroy(self):
        # remove actors and sensors
        for actor_dic in self.actors_batch:
            actor_dic['Actor'].destroy()
            actor_dic['Sensor'].destroy()

    def tick(self):
        for actor_dic in self.actors_batch:
            control = actor_dic['Cruise Control']
            state = control.tick()
            s = self.estimate_s(control.s, state[0], state[1], state[-1])
            actor_dic['Frenet State'][0].append(s)  # append current actor s value
            # actor_dic['Frenet State'][0] = s
            # IMPORTANT actor d is NOT updated
            control.update_s(s)


class LineOfSightSensor(object):
    def __init__(self, parent_actor):
        self.sensor = None
        self.distance = None
        self.vehicle_ahead = None
        self._parent = parent_actor
        # self.sensor_transform = carla.Transform(carla.Location(x=4, z=1.7), carla.Rotation(yaw=0)) # Put this sensor on the windshield of the car.
        world = self._parent.get_world()
        bp = world.get_blueprint_library().find('sensor.other.obstacle')
        bp.set_attribute('distance', '200')
        bp.set_attribute('hit_radius', '0.5')
        bp.set_attribute('only_dynamics', 'True')
        bp.set_attribute('debug_linetrace', 'False')
        bp.set_attribute('sensor_tick', '0.0')
        self.sensor = world.spawn_actor(bp, carla.Transform(), attach_to=self._parent)
        weak_self = weakref.ref(self)
        self.sensor.listen(lambda event: LineOfSightSensor._on_los(weak_self, event))

    def reset(self):
        self.vehicle_ahead = None
        self.distance = None

    def destroy(self):
        self.sensor.destroy()

    def get_vehicle_ahead(self):
        return self.vehicle_ahead

    # Only works for CARLA 9.6 and above!
    def get_los_distance(self):
        return self.distance

    @staticmethod
    def _on_los(weak_self, event):
        self = weak_self()
        if not self:
            return
        self.vehicle_ahead = event.other_actor
        self.distance = event.distance


# ==============================================================================
# -- Vehicle Cruise Control ----------------------------------------------------
# ==============================================================================


class CruiseControl:
    def __init__(self, vehicle, los_sensor, s, d, lane, module_manager, targetSpeed=50 / 3.6):
        self.vehicle = vehicle  # Carla instance for the vehicle
        self.id = self.vehicle.id
        self.s = s
        self.d = d  # actor won't change lane so d is constant
        self.lane = lane
        self.module_manager = module_manager
        self.targetSpeed = targetSpeed
        self.world = self.module_manager.get_module(MODULE_WORLD)
        self.steps = 0
        if float(cfg.CARLA.DT) > 0:
            self.dt = float(cfg.CARLA.DT)
        else:
            self.dt = 0.05
        self.vehicleController = VehiclePIDController(self.vehicle)
        self.IDM = IntelligentDriverModel(self.vehicle)

        self.los_sensor = los_sensor

        self.location = self.vehicle.get_location()
        self.speed = get_speed(self.vehicle)
        self.acceleration = 0
        self.yaw = math.radians(self.vehicle.get_transform().rotation.yaw)
        self.LANE_WIDTH = float(cfg.CARLA.LANE_WIDTH)

    def update_s(self, s):
        self.s = s

    def inertial_to_body_frame(self, xi, yi):
        Xi = np.array([xi, yi])  # inertial frame
        R_psi_T = np.array([[np.cos(self.yaw), np.sin(self.yaw)],  # Rotation matrix transpose
                            [-np.sin(self.yaw), np.cos(self.yaw)]])
        Xt = np.array([self.location.x,  # Translation from inertial to body frame
                       self.location.y])
        Xb = np.matmul(R_psi_T, Xi - Xt)
        return Xb

    def body_to_inertial_frame(self, xb, yb):
        Xb = np.array([xb, yb])  # inertial frame
        R_psi = np.array([[np.cos(self.yaw), -np.sin(self.yaw)],  # Rotation matrix
                          [np.sin(self.yaw), np.cos(self.yaw)]])
        Xt = np.array([self.location.x,  # Translation from inertial to body frame
                       self.location.y])
        Xi = np.matmul(R_psi, Xb) + Xt
        return Xi

    def tick(self):
        self.steps += 1
        self.location = self.vehicle.get_location()
        speed_ = self.speed # speed in previous tick
        self.speed = get_speed(self.vehicle)
        self.acceleration = (self.speed - speed_) / self.dt
        self.yaw = math.radians(self.vehicle.get_transform().rotation.yaw)

        nextWP = self.world.town_map.get_waypoint(self.location, project_to_road=True).next(distance=5)[0]
        targetWP = [nextWP.transform.location.x, nextWP.transform.location.y]

        if self.lane == 2 and nextWP.is_junction:  # only if in right most lane
            temploc = self.body_to_inertial_frame(xb=0, yb=-self.LANE_WIDTH)
            tempWP = self.world.town_map.get_waypoint(carla.Location(x=temploc[0], y=temploc[1]), project_to_road=True).next(distance=10)[0]
            tempWPb = self.inertial_to_body_frame(xi=tempWP.transform.location.x, yi=tempWP.transform.location.y)
            targetWP = self.body_to_inertial_frame(xb=tempWPb[0], yb=tempWPb[1] + self.LANE_WIDTH)

        vehicle_ahead = self.los_sensor.get_vehicle_ahead()
        cmdSpeed = self.IDM.run_step(vd=self.targetSpeed, vehicle_ahead=vehicle_ahead)

        control = self.vehicleController.run_step(cmdSpeed, targetWP)
        self.vehicle.apply_control(control)

        return [self.location.x, self.location.y, self.location.z, self.speed, self.acceleration, self.yaw]